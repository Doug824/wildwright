"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const non_secure_1 = require("nanoid/non-secure");
function createMemoryHistory() {
    let index = 0;
    let items = [];
    // Pending callbacks for `history.go(n)`
    // We might modify the callback stored if it was interrupted, so we have a ref to identify it
    const pending = [];
    const interrupt = () => {
        // If another history operation was performed we need to interrupt existing ones
        // This makes sure that calls such as `history.replace` after `history.go` don't happen
        // Since otherwise it won't be correct if something else has changed
        pending.forEach((it) => {
            const cb = it.cb;
            it.cb = () => cb(true);
        });
    };
    const history = {
        get index() {
            // We store an id in the state instead of an index
            // Index could get out of sync with in-memory values if page reloads
            const id = window.history.state?.id;
            if (id) {
                const index = items.findIndex((item) => item.id === id);
                return index > -1 ? index : 0;
            }
            return 0;
        },
        get(index) {
            return items[index];
        },
        backIndex({ path }) {
            // We need to find the index from the element before current to get closest path to go back to
            for (let i = index - 1; i >= 0; i--) {
                const item = items[i];
                if (item.path === path) 